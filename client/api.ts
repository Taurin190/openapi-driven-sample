/* tslint:disable */
/* eslint-disable */
/**
 * Taurin190.com
 * This is an **example** API to demonstrate features of the OpenAPI specification.  # Introduction  This API definition is intended to to be a good starting point for describing your API in   [OpenAPI/Swagger format](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md).  It also demonstrates features of the [create-openapi-repo](https://github.com/Redocly/create-openapi-repo) tool and   the [Redoc](https://github.com/Redocly/Redoc) documentation engine. Beyond the standard OpenAPI syntax, we use a few   [vendor extensions](https://github.com/Redocly/Redoc/blob/master/docs/redoc-vendor-extensions.md).   # OpenAPI Specification  The goal of The OpenAPI Specification is to define a standard, language-agnostic interface to REST APIs which  allows both humans and computers to discover and understand the capabilities of the service without access to source  code, documentation, or through network traffic inspection. When properly defined via OpenAPI, a consumer can   understand and interact with the remote service with a minimal amount of implementation logic. Similar to what  interfaces have done for lower-level programming, OpenAPI removes the guesswork in calling the service.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base";

/**
 * The Problem Details JSON Object [[RFC7807](https://tools.ietf.org/html/rfc7807)].
 * @export
 * @interface Problem
 */
export interface Problem {
  [key: string]: any;

  /**
   * A URI reference [[RFC3986](https://tools.ietf.org/html/rfc3986)] that identifies the problem type. It should provide human-readable documentation for the problem type. When this member is not present, its value is assumed to be \"about:blank\".
   * @type {any}
   * @memberof Problem
   */
  type?: any;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
   * @type {any}
   * @memberof Problem
   */
  title?: any;
  /**
   * The HTTP status code.
   * @type {any}
   * @memberof Problem
   */
  status?: any;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {any}
   * @memberof Problem
   */
  detail?: any;
  /**
   * A URI reference that identifies the specific occurrence of the problem.  It may or may not yield further information if dereferenced.
   * @type {any}
   * @memberof Problem
   */
  instance?: any;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   * User Unique ID
   * @type {any}
   * @memberof User
   */
  user_id?: any;
  /**
   * User supplied username
   * @type {any}
   * @memberof User
   */
  userName?: any;
  /**
   * User first name
   * @type {any}
   * @memberof User
   */
  firstName?: any;
  /**
   * User last name
   * @type {any}
   * @memberof User
   */
  lastName?: any;
  /**
   * User email address
   * @type {any}
   * @memberof User
   */
  email?: any;
  /**
   * Created datetime
   * @type {any}
   * @memberof User
   */
  createdAt?: any;
  /**
   * Role Unique ID
   * @type {any}
   * @memberof User
   */
  roleId?: any;
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Delete unnecessary users. User who has permisssion can delete users.
     * @summary Delete user
     * @param {any} userId The name that needs to be updated
     * @param {User} user Updated user object
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userId: any,
      user: User,
      prettyPrint?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteUser", "userId", userId);
      // verify required parameter 'user' is not null or undefined
      assertParamExists("deleteUser", "user", user);
      const localVarPath = `/api/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication main_auth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "main_auth",
        ["write:users"],
        configuration
      );

      if (prettyPrint !== undefined) {
        localVarQueryParameter["pretty_print"] = prettyPrint;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Some description of the operation. You can use `Markdown` here.
     * @summary Get user detail by user id
     * @param {any} userId The name that needs to be fetched
     * @param {any} [withEmail] Filter users without email
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByName: async (
      userId: any,
      withEmail?: any,
      prettyPrint?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getUserByName", "userId", userId);
      const localVarPath = `/api/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication api_key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "api_key",
        configuration
      );

      // authentication main_auth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "main_auth",
        ["read:users"],
        configuration
      );

      if (withEmail !== undefined) {
        localVarQueryParameter["with_email"] = withEmail;
      }

      if (prettyPrint !== undefined) {
        localVarQueryParameter["pretty_print"] = prettyPrint;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all active users with limited number and pages. You can select limit from 10, 50, 100.
     * @summary Get all users with pager
     * @param {any} [limit] Limit number users to acquire
     * @param {any} [page] Page number
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      limit?: any,
      page?: any,
      prettyPrint?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication api_key required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "api_key",
        configuration
      );

      // authentication main_auth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "main_auth",
        ["read:users"],
        configuration
      );

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (prettyPrint !== undefined) {
        localVarQueryParameter["pretty_print"] = prettyPrint;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {any} userId The name that needs to be updated
     * @param {User} user Updated user object
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userId: any,
      user: User,
      prettyPrint?: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("updateUser", "userId", userId);
      // verify required parameter 'user' is not null or undefined
      assertParamExists("updateUser", "user", user);
      const localVarPath = `/api/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication main_auth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "main_auth",
        ["write:users"],
        configuration
      );

      if (prettyPrint !== undefined) {
        localVarQueryParameter["pretty_print"] = prettyPrint;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * Delete unnecessary users. User who has permisssion can delete users.
     * @summary Delete user
     * @param {any} userId The name that needs to be updated
     * @param {User} user Updated user object
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userId: any,
      user: User,
      prettyPrint?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        userId,
        user,
        prettyPrint,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Some description of the operation. You can use `Markdown` here.
     * @summary Get user detail by user id
     * @param {any} userId The name that needs to be fetched
     * @param {any} [withEmail] Filter users without email
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserByName(
      userId: any,
      withEmail?: any,
      prettyPrint?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByName(
        userId,
        withEmail,
        prettyPrint,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get all active users with limited number and pages. You can select limit from 10, 50, 100.
     * @summary Get all users with pager
     * @param {any} [limit] Limit number users to acquire
     * @param {any} [page] Page number
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      limit?: any,
      page?: any,
      prettyPrint?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        limit,
        page,
        prettyPrint,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {any} userId The name that needs to be updated
     * @param {User} user Updated user object
     * @param {any} [prettyPrint] Pretty print response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userId: any,
      user: User,
      prettyPrint?: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        userId,
        user,
        prettyPrint,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * Delete unnecessary users. User who has permisssion can delete users.
     * @summary Delete user
     * @param {UserApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      requestParameters: UserApiDeleteUserRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUser(
          requestParameters.userId,
          requestParameters.user,
          requestParameters.prettyPrint,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Some description of the operation. You can use `Markdown` here.
     * @summary Get user detail by user id
     * @param {UserApiGetUserByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByName(
      requestParameters: UserApiGetUserByNameRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .getUserByName(
          requestParameters.userId,
          requestParameters.withEmail,
          requestParameters.prettyPrint,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get all active users with limited number and pages. You can select limit from 10, 50, 100.
     * @summary Get all users with pager
     * @param {UserApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      requestParameters: UserApiGetUsersRequest = {},
      options?: AxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .getUsers(
          requestParameters.limit,
          requestParameters.page,
          requestParameters.prettyPrint,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      requestParameters: UserApiUpdateUserRequest,
      options?: AxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .updateUser(
          requestParameters.userId,
          requestParameters.user,
          requestParameters.prettyPrint,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for deleteUser operation in UserApi.
 * @export
 * @interface UserApiDeleteUserRequest
 */
export interface UserApiDeleteUserRequest {
  /**
   * The name that needs to be updated
   * @type {any}
   * @memberof UserApiDeleteUser
   */
  readonly userId: any;

  /**
   * Updated user object
   * @type {User}
   * @memberof UserApiDeleteUser
   */
  readonly user: User;

  /**
   * Pretty print response
   * @type {any}
   * @memberof UserApiDeleteUser
   */
  readonly prettyPrint?: any;
}

/**
 * Request parameters for getUserByName operation in UserApi.
 * @export
 * @interface UserApiGetUserByNameRequest
 */
export interface UserApiGetUserByNameRequest {
  /**
   * The name that needs to be fetched
   * @type {any}
   * @memberof UserApiGetUserByName
   */
  readonly userId: any;

  /**
   * Filter users without email
   * @type {any}
   * @memberof UserApiGetUserByName
   */
  readonly withEmail?: any;

  /**
   * Pretty print response
   * @type {any}
   * @memberof UserApiGetUserByName
   */
  readonly prettyPrint?: any;
}

/**
 * Request parameters for getUsers operation in UserApi.
 * @export
 * @interface UserApiGetUsersRequest
 */
export interface UserApiGetUsersRequest {
  /**
   * Limit number users to acquire
   * @type {any}
   * @memberof UserApiGetUsers
   */
  readonly limit?: any;

  /**
   * Page number
   * @type {any}
   * @memberof UserApiGetUsers
   */
  readonly page?: any;

  /**
   * Pretty print response
   * @type {any}
   * @memberof UserApiGetUsers
   */
  readonly prettyPrint?: any;
}

/**
 * Request parameters for updateUser operation in UserApi.
 * @export
 * @interface UserApiUpdateUserRequest
 */
export interface UserApiUpdateUserRequest {
  /**
   * The name that needs to be updated
   * @type {any}
   * @memberof UserApiUpdateUser
   */
  readonly userId: any;

  /**
   * Updated user object
   * @type {User}
   * @memberof UserApiUpdateUser
   */
  readonly user: User;

  /**
   * Pretty print response
   * @type {any}
   * @memberof UserApiUpdateUser
   */
  readonly prettyPrint?: any;
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * Delete unnecessary users. User who has permisssion can delete users.
   * @summary Delete user
   * @param {UserApiDeleteUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public deleteUser(
    requestParameters: UserApiDeleteUserRequest,
    options?: AxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .deleteUser(
        requestParameters.userId,
        requestParameters.user,
        requestParameters.prettyPrint,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Some description of the operation. You can use `Markdown` here.
   * @summary Get user detail by user id
   * @param {UserApiGetUserByNameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserByName(
    requestParameters: UserApiGetUserByNameRequest,
    options?: AxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .getUserByName(
        requestParameters.userId,
        requestParameters.withEmail,
        requestParameters.prettyPrint,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all active users with limited number and pages. You can select limit from 10, 50, 100.
   * @summary Get all users with pager
   * @param {UserApiGetUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUsers(
    requestParameters: UserApiGetUsersRequest = {},
    options?: AxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .getUsers(
        requestParameters.limit,
        requestParameters.page,
        requestParameters.prettyPrint,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This can only be done by the logged in user.
   * @summary Updated user
   * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateUser(
    requestParameters: UserApiUpdateUserRequest,
    options?: AxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .updateUser(
        requestParameters.userId,
        requestParameters.user,
        requestParameters.prettyPrint,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
